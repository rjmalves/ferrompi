<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="An MPI communicator."><title>Communicator in ferrompi - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="ferrompi" data-themes="" data-resource-suffix="" data-rustdoc-version="1.93.1 (01f6ddf75 2026-02-11)" data-channel="1.93.1" data-search-js="search-9e2438ea.js" data-stringdex-js="stringdex-a3946164.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-a410ff4d.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Communicator</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../ferrompi/index.html">ferrompi</a><span class="version">0.2.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Communicator</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#thread-safety" title="Thread Safety">Thread Safety</a></li><li><a href="#example" title="Example">Example</a></li></ul><h3><a href="#implementations">Associated Constants</a></h3><ul class="block associatedconstant"><li><a href="#associatedconstant.UNDEFINED" title="UNDEFINED">UNDEFINED</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.abort" title="abort">abort</a></li><li><a href="#method.allgather" title="allgather">allgather</a></li><li><a href="#method.allgather_init" title="allgather_init">allgather_init</a></li><li><a href="#method.allgatherv" title="allgatherv">allgatherv</a></li><li><a href="#method.allgatherv_init" title="allgatherv_init">allgatherv_init</a></li><li><a href="#method.allreduce" title="allreduce">allreduce</a></li><li><a href="#method.allreduce_init" title="allreduce_init">allreduce_init</a></li><li><a href="#method.allreduce_init_inplace" title="allreduce_init_inplace">allreduce_init_inplace</a></li><li><a href="#method.allreduce_inplace" title="allreduce_inplace">allreduce_inplace</a></li><li><a href="#method.allreduce_scalar" title="allreduce_scalar">allreduce_scalar</a></li><li><a href="#method.alltoall" title="alltoall">alltoall</a></li><li><a href="#method.alltoall_init" title="alltoall_init">alltoall_init</a></li><li><a href="#method.alltoallv" title="alltoallv">alltoallv</a></li><li><a href="#method.alltoallv_init" title="alltoallv_init">alltoallv_init</a></li><li><a href="#method.barrier" title="barrier">barrier</a></li><li><a href="#method.bcast_init" title="bcast_init">bcast_init</a></li><li><a href="#method.broadcast" title="broadcast">broadcast</a></li><li><a href="#method.duplicate" title="duplicate">duplicate</a></li><li><a href="#method.exscan" title="exscan">exscan</a></li><li><a href="#method.exscan_init" title="exscan_init">exscan_init</a></li><li><a href="#method.exscan_scalar" title="exscan_scalar">exscan_scalar</a></li><li><a href="#method.gather" title="gather">gather</a></li><li><a href="#method.gather_init" title="gather_init">gather_init</a></li><li><a href="#method.gatherv" title="gatherv">gatherv</a></li><li><a href="#method.gatherv_init" title="gatherv_init">gatherv_init</a></li><li><a href="#method.iallgather" title="iallgather">iallgather</a></li><li><a href="#method.iallgatherv" title="iallgatherv">iallgatherv</a></li><li><a href="#method.iallreduce" title="iallreduce">iallreduce</a></li><li><a href="#method.ialltoall" title="ialltoall">ialltoall</a></li><li><a href="#method.ialltoallv" title="ialltoallv">ialltoallv</a></li><li><a href="#method.ibarrier" title="ibarrier">ibarrier</a></li><li><a href="#method.ibroadcast" title="ibroadcast">ibroadcast</a></li><li><a href="#method.iexscan" title="iexscan">iexscan</a></li><li><a href="#method.igather" title="igather">igather</a></li><li><a href="#method.igatherv" title="igatherv">igatherv</a></li><li><a href="#method.iprobe" title="iprobe">iprobe</a></li><li><a href="#method.irecv" title="irecv">irecv</a></li><li><a href="#method.ireduce" title="ireduce">ireduce</a></li><li><a href="#method.ireduce_scatter_block" title="ireduce_scatter_block">ireduce_scatter_block</a></li><li><a href="#method.iscan" title="iscan">iscan</a></li><li><a href="#method.iscatter" title="iscatter">iscatter</a></li><li><a href="#method.iscatterv" title="iscatterv">iscatterv</a></li><li><a href="#method.isend" title="isend">isend</a></li><li><a href="#method.probe" title="probe">probe</a></li><li><a href="#method.processor_name" title="processor_name">processor_name</a></li><li><a href="#method.rank" title="rank">rank</a></li><li><a href="#method.raw_handle" title="raw_handle">raw_handle</a></li><li><a href="#method.recv" title="recv">recv</a></li><li><a href="#method.reduce" title="reduce">reduce</a></li><li><a href="#method.reduce_init" title="reduce_init">reduce_init</a></li><li><a href="#method.reduce_inplace" title="reduce_inplace">reduce_inplace</a></li><li><a href="#method.reduce_scalar" title="reduce_scalar">reduce_scalar</a></li><li><a href="#method.reduce_scatter_block" title="reduce_scatter_block">reduce_scatter_block</a></li><li><a href="#method.reduce_scatter_block_init" title="reduce_scatter_block_init">reduce_scatter_block_init</a></li><li><a href="#method.scan" title="scan">scan</a></li><li><a href="#method.scan_init" title="scan_init">scan_init</a></li><li><a href="#method.scan_scalar" title="scan_scalar">scan_scalar</a></li><li><a href="#method.scatter" title="scatter">scatter</a></li><li><a href="#method.scatter_init" title="scatter_init">scatter_init</a></li><li><a href="#method.scatterv" title="scatterv">scatterv</a></li><li><a href="#method.scatterv_init" title="scatterv_init">scatterv_init</a></li><li><a href="#method.send" title="send">send</a></li><li><a href="#method.sendrecv" title="sendrecv">sendrecv</a></li><li><a href="#method.size" title="size">size</a></li><li><a href="#method.split" title="split">split</a></li><li><a href="#method.split_shared" title="split_shared">split_shared</a></li><li><a href="#method.split_type" title="split_type">split_type</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-Communicator" title="Clone">Clone</a></li><li><a href="#impl-Drop-for-Communicator" title="Drop">Drop</a></li><li><a href="#impl-Send-for-Communicator" title="Send">Send</a></li><li><a href="#impl-Sync-for-Communicator" title="Sync">Sync</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-Communicator" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Communicator" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Unpin-for-Communicator" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Communicator" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate ferrompi</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">ferrompi</a></div><h1>Struct <span class="struct">Communicator</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/ferrompi/comm.rs.html#60-62">Source</a> </span></div><pre class="rust item-decl"><code>pub struct Communicator { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>An MPI communicator.</p>
<p>This type wraps an MPI communicator handle and provides safe methods for
collective and point-to-point communication operations.</p>
<h2 id="thread-safety"><a class="doc-anchor" href="#thread-safety">§</a>Thread Safety</h2>
<p><code>Communicator</code> is <code>Send + Sync</code>, matching the thread-safety model of
C/Fortran MPI. The actual thread-safety guarantees depend on the
thread level provided by <a href="struct.Mpi.html#method.init_thread" title="associated function ferrompi::Mpi::init_thread"><code>Mpi::init_thread()</code></a>:</p>
<ul>
<li><a href="enum.ThreadLevel.html#variant.Single" title="variant ferrompi::ThreadLevel::Single"><code>ThreadLevel::Single</code></a> /
<a href="enum.ThreadLevel.html#variant.Funneled" title="variant ferrompi::ThreadLevel::Funneled"><code>Funneled</code></a>: MPI calls only from main thread</li>
<li><a href="enum.ThreadLevel.html#variant.Serialized" title="variant ferrompi::ThreadLevel::Serialized"><code>ThreadLevel::Serialized</code></a>: MPI calls
from any thread, but serialized by the user (e.g., via a <code>Mutex</code>)</li>
<li><a href="enum.ThreadLevel.html#variant.Multiple" title="variant ferrompi::ThreadLevel::Multiple"><code>ThreadLevel::Multiple</code></a>: MPI calls from
any thread concurrently without external synchronization</li>
</ul>
<p>For hybrid MPI + threads programs, request at least
<a href="enum.ThreadLevel.html#variant.Funneled" title="variant ferrompi::ThreadLevel::Funneled"><code>ThreadLevel::Funneled</code></a> (master thread
makes MPI calls) or <a href="enum.ThreadLevel.html#variant.Serialized" title="variant ferrompi::ThreadLevel::Serialized"><code>ThreadLevel::Serialized</code></a>
(any thread, but only one at a time).</p>
<h2 id="example"><a class="doc-anchor" href="#example">§</a>Example</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ferrompi::Mpi;

<span class="kw">let </span>mpi = Mpi::init().unwrap();
<span class="kw">let </span>world = mpi.world();

<span class="macro">println!</span>(<span class="string">"I am rank {} of {}"</span>, world.rank(), world.size());</code></pre></div></div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Communicator" class="impl"><a class="src rightside" href="../src/ferrompi/comm.rs.html#74-2860">Source</a><a href="#impl-Communicator" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Communicator.html" title="struct ferrompi::Communicator">Communicator</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.UNDEFINED" class="associatedconstant"><a class="src rightside" href="../src/ferrompi/comm.rs.html#79">Source</a><h4 class="code-header">pub const <a href="#associatedconstant.UNDEFINED" class="constant">UNDEFINED</a>: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a> = -1</h4></section></summary><div class="docblock"><p>Constant for opting out of a communicator split.</p>
<p>Processes passing this as the <code>color</code> to <a href="struct.Communicator.html#method.split" title="method ferrompi::Communicator::split"><code>split()</code></a> will not be
included in any resulting communicator.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.raw_handle" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#89-91">Source</a><h4 class="code-header">pub fn <a href="#method.raw_handle" class="fn">raw_handle</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a></h4></section></summary><div class="docblock"><p>Get the raw communicator handle (for advanced use).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rank" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#94-98">Source</a><h4 class="code-header">pub fn <a href="#method.rank" class="fn">rank</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a></h4></section></summary><div class="docblock"><p>Get the rank of the calling process in this communicator.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.size" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#101-105">Source</a><h4 class="code-header">pub fn <a href="#method.size" class="fn">size</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a></h4></section></summary><div class="docblock"><p>Get the number of processes in this communicator.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.processor_name" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#108-118">Source</a><h4 class="code-header">pub fn <a href="#method.processor_name" class="fn">processor_name</a>(&amp;self) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.93.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;</h4></section></summary><div class="docblock"><p>Get the processor name for this process.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.duplicate" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#121-126">Source</a><h4 class="code-header">pub fn <a href="#method.duplicate" class="fn">duplicate</a>(&amp;self) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Duplicate this communicator.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#147-156">Source</a><h4 class="code-header">pub fn <a href="#method.split" class="fn">split</a>(&amp;self, color: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>, key: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.93.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Communicator.html" title="struct ferrompi::Communicator">Communicator</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Split this communicator into sub-communicators based on color and key.</p>
<p>Processes with the same <code>color</code> are placed in the same new communicator.
The <code>key</code> controls the rank ordering within the new communicator.</p>
<p>Returns <code>None</code> if this process used <a href="struct.Communicator.html#associatedconstant.UNDEFINED" title="associated constant ferrompi::Communicator::UNDEFINED"><code>Communicator::UNDEFINED</code></a> as color.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ferrompi::Mpi;

<span class="kw">let </span>mpi = Mpi::init().unwrap();
<span class="kw">let </span>world = mpi.world();
<span class="kw">let </span>color = world.rank() % <span class="number">2</span>; <span class="comment">// Even/odd split
</span><span class="kw">if let </span><span class="prelude-val">Some</span>(sub) = world.split(color, world.rank()).unwrap() {
    <span class="macro">println!</span>(<span class="string">"Rank {} in sub-communicator of size {}"</span>, sub.rank(), sub.size());
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.split_type" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#177-188">Source</a><h4 class="code-header">pub fn <a href="#method.split_type" class="fn">split_type</a>(
    &amp;self,
    split_type: <a class="enum" href="enum.SplitType.html" title="enum ferrompi::SplitType">SplitType</a>,
    key: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.93.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Communicator.html" title="struct ferrompi::Communicator">Communicator</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Split this communicator by type.</p>
<p>Processes that share the same resource (determined by <code>split_type</code>) are
placed in the same new communicator. The <code>key</code> controls the rank ordering
within the new communicator.</p>
<p>Returns <code>None</code> if MPI returns <code>MPI_COMM_NULL</code> for this process.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ferrompi::{Mpi, SplitType};

<span class="kw">let </span>mpi = Mpi::init().unwrap();
<span class="kw">let </span>world = mpi.world();
<span class="kw">if let </span><span class="prelude-val">Some</span>(node) = world.split_type(SplitType::Shared, world.rank()).unwrap() {
    <span class="macro">println!</span>(<span class="string">"Node has {} processes"</span>, node.size());
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.split_shared" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#210-213">Source</a><h4 class="code-header">pub fn <a href="#method.split_shared" class="fn">split_shared</a>(&amp;self) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.Communicator.html" title="struct ferrompi::Communicator">Communicator</a>&gt;</h4></section></summary><div class="docblock"><p>Create a communicator containing only processes that share memory.</p>
<p>This is equivalent to <code>split_type(SplitType::Shared, self.rank())</code>.
All processes on the same physical node will be in the same communicator.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h5>
<p>Returns <a href="enum.Error.html#variant.Internal" title="variant ferrompi::Error::Internal"><code>Error::Internal</code></a> if MPI unexpectedly returns a null communicator,
which should not happen for <code>MPI_COMM_TYPE_SHARED</code> under normal conditions.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ferrompi::Mpi;

<span class="kw">let </span>mpi = Mpi::init().unwrap();
<span class="kw">let </span>world = mpi.world();
<span class="kw">let </span>node = world.split_shared().unwrap();
<span class="macro">println!</span>(<span class="string">"Node has {} processes, I am local rank {}"</span>, node.size(), node.rank());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.barrier" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#223-226">Source</a><h4 class="code-header">pub fn <a href="#method.barrier" class="fn">barrier</a>(&amp;self) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Barrier synchronization.</p>
<p>All processes in the communicator must call this function. No process
will return until all processes have entered the barrier.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.send" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#249-261">Source</a><h4 class="code-header">pub fn <a href="#method.send" class="fn">send</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    data: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    dest: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
    tag: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Send a slice of values to another process.</p>
<h5 id="arguments"><a class="doc-anchor" href="#arguments">§</a>Arguments</h5>
<ul>
<li><code>data</code> - Buffer to send</li>
<li><code>dest</code> - Destination rank</li>
<li><code>tag</code> - Message tag</li>
</ul>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>data = <span class="macro">vec!</span>[<span class="number">1.0f64</span>, <span class="number">2.0</span>, <span class="number">3.0</span>];
world.send(<span class="kw-2">&amp;</span>data, <span class="number">1</span>, <span class="number">0</span>).unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.recv" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#278-303">Source</a><h4 class="code-header">pub fn <a href="#method.recv" class="fn">recv</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    data: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    source: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
    tag: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;(<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>, <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>, <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i64.html">i64</a>)&gt;</h4></section></summary><div class="docblock"><p>Receive a slice of values from another process.</p>
<p>Use <code>source = -1</code> for <code>MPI_ANY_SOURCE</code> and <code>tag = -1</code> for <code>MPI_ANY_TAG</code>.</p>
<p>Returns <code>(actual_source, actual_tag, actual_count)</code>.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span>(source, tag, count) = world.recv(<span class="kw-2">&amp;mut </span>buf, <span class="number">0</span>, <span class="number">0</span>).unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.isend" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#328-343">Source</a><h4 class="code-header">pub fn <a href="#method.isend" class="fn">isend</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    data: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    dest: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
    tag: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.Request.html" title="struct ferrompi::Request">Request</a>&gt;</h4></section></summary><div class="docblock"><p>Nonblocking send.</p>
<p>Initiates a send operation and returns immediately with a <a href="struct.Request.html" title="struct ferrompi::Request"><code>Request</code></a>
handle. The send buffer <strong>must not be modified</strong> until the request is
completed via <a href="struct.Request.html#method.wait" title="method ferrompi::Request::wait"><code>Request::wait()</code></a> or <a href="struct.Request.html#method.test" title="method ferrompi::Request::test"><code>Request::test()</code></a>.</p>
<h5 id="arguments-1"><a class="doc-anchor" href="#arguments-1">§</a>Arguments</h5>
<ul>
<li><code>data</code> - Buffer to send (must remain valid until the request completes)</li>
<li><code>dest</code> - Destination rank</li>
<li><code>tag</code> - Message tag</li>
</ul>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>data = <span class="macro">vec!</span>[<span class="number">1.0f64</span>, <span class="number">2.0</span>, <span class="number">3.0</span>];
<span class="kw">let </span>req = world.isend(<span class="kw-2">&amp;</span>data, <span class="number">1</span>, <span class="number">0</span>).unwrap();
<span class="comment">// ... do other work ...
</span>req.wait().unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.irecv" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#370-385">Source</a><h4 class="code-header">pub fn <a href="#method.irecv" class="fn">irecv</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    data: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    source: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
    tag: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.Request.html" title="struct ferrompi::Request">Request</a>&gt;</h4></section></summary><div class="docblock"><p>Nonblocking receive.</p>
<p>Initiates a receive operation and returns immediately with a <a href="struct.Request.html" title="struct ferrompi::Request"><code>Request</code></a>
handle. The receive buffer <strong>must not be read</strong> until the request is
completed via <a href="struct.Request.html#method.wait" title="method ferrompi::Request::wait"><code>Request::wait()</code></a> or <a href="struct.Request.html#method.test" title="method ferrompi::Request::test"><code>Request::test()</code></a>.</p>
<p>Use <code>source = -1</code> for <code>MPI_ANY_SOURCE</code> and <code>tag = -1</code> for <code>MPI_ANY_TAG</code>.</p>
<h5 id="arguments-2"><a class="doc-anchor" href="#arguments-2">§</a>Arguments</h5>
<ul>
<li><code>data</code> - Receive buffer (must remain valid until the request completes)</li>
<li><code>source</code> - Source rank (or -1 for any source)</li>
<li><code>tag</code> - Message tag (or -1 for any tag)</li>
</ul>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span>req = world.irecv(<span class="kw-2">&amp;mut </span>buf, <span class="number">0</span>, <span class="number">0</span>).unwrap();
<span class="comment">// ... do other work ...
</span>req.wait().unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.sendrecv" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#418-451">Source</a><h4 class="code-header">pub fn <a href="#method.sendrecv" class="fn">sendrecv</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    dest: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
    sendtag: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    source: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
    recvtag: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;(<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>, <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>, <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i64.html">i64</a>)&gt;</h4></section></summary><div class="docblock"><p>Blocking send-receive.</p>
<p>Sends data to one process and receives from another (or the same) in a
single operation. This is useful for avoiding deadlocks in ring-style
communication patterns where each process both sends and receives.</p>
<p>Use <code>source = -1</code> for <code>MPI_ANY_SOURCE</code> and <code>recvtag = -1</code> for <code>MPI_ANY_TAG</code>.</p>
<p>Returns <code>(actual_source, actual_tag, actual_count)</code>.</p>
<h5 id="arguments-3"><a class="doc-anchor" href="#arguments-3">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Buffer to send</li>
<li><code>dest</code> - Destination rank</li>
<li><code>sendtag</code> - Send message tag</li>
<li><code>recv</code> - Receive buffer</li>
<li><code>source</code> - Source rank (or -1 for any source)</li>
<li><code>recvtag</code> - Receive message tag (or -1 for any tag)</li>
</ul>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>send = <span class="macro">vec!</span>[world.rank() <span class="kw">as </span>f64; <span class="number">5</span>];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">5</span>];
<span class="kw">let </span>next = (world.rank() + <span class="number">1</span>) % world.size();
<span class="kw">let </span>prev = (world.rank() - <span class="number">1 </span>+ world.size()) % world.size();
<span class="kw">let </span>(src, tag, count) = world.sendrecv(<span class="kw-2">&amp;</span>send, next, <span class="number">0</span>, <span class="kw-2">&amp;mut </span>recv, prev, <span class="number">0</span>).unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.probe" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#487-509">Source</a><h4 class="code-header">pub fn <a href="#method.probe" class="fn">probe</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(&amp;self, source: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>, tag: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.Status.html" title="struct ferrompi::Status">Status</a>&gt;</h4></section></summary><div class="docblock"><p>Blocking probe for an incoming message.</p>
<p>Waits until a matching message is available and returns status
information (source rank, tag, element count) without actually
receiving the message. This is useful for determining the size of an
incoming message before allocating a receive buffer.</p>
<p>Use <code>source = -1</code> for <code>MPI_ANY_SOURCE</code> and <code>tag = -1</code> for <code>MPI_ANY_TAG</code>.</p>
<p>The type parameter <code>T</code> determines the MPI datatype used by
<code>MPI_Get_count</code> to compute the element count in the returned
<a href="struct.Status.html" title="struct ferrompi::Status"><code>Status</code></a>.</p>
<h5 id="arguments-4"><a class="doc-anchor" href="#arguments-4">§</a>Arguments</h5>
<ul>
<li><code>source</code> - Source rank to match (or -1 for any source)</li>
<li><code>tag</code> - Message tag to match (or -1 for any tag)</li>
</ul>
<h5 id="example-9"><a class="doc-anchor" href="#example-9">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Probe for any incoming f64 message
</span><span class="kw">let </span>status = world.probe::&lt;f64&gt;(-<span class="number">1</span>, -<span class="number">1</span>).unwrap();
<span class="comment">// Allocate a buffer of exactly the right size
</span><span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; status.count <span class="kw">as </span>usize];
world.recv(<span class="kw-2">&amp;mut </span>buf, status.source, status.tag).unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.iprobe" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#539-567">Source</a><h4 class="code-header">pub fn <a href="#method.iprobe" class="fn">iprobe</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    source: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
    tag: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.93.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Status.html" title="struct ferrompi::Status">Status</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Nonblocking probe for an incoming message.</p>
<p>Checks whether a matching message is available without blocking.
Returns <code>Some(Status)</code> if a message is available, <code>None</code> otherwise.</p>
<p>Use <code>source = -1</code> for <code>MPI_ANY_SOURCE</code> and <code>tag = -1</code> for <code>MPI_ANY_TAG</code>.</p>
<p>The type parameter <code>T</code> determines the MPI datatype used by
<code>MPI_Get_count</code> to compute the element count in the returned
<a href="struct.Status.html" title="struct ferrompi::Status"><code>Status</code></a>.</p>
<h5 id="arguments-5"><a class="doc-anchor" href="#arguments-5">§</a>Arguments</h5>
<ul>
<li><code>source</code> - Source rank to match (or -1 for any source)</li>
<li><code>tag</code> - Message tag to match (or -1 for any tag)</li>
</ul>
<h5 id="example-10"><a class="doc-anchor" href="#example-10">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Poll for an incoming f64 message without blocking
</span><span class="kw">if let </span><span class="prelude-val">Some</span>(status) = world.iprobe::&lt;f64&gt;(-<span class="number">1</span>, -<span class="number">1</span>).unwrap() {
    <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; status.count <span class="kw">as </span>usize];
    world.recv(<span class="kw-2">&amp;mut </span>buf, status.source, status.tag).unwrap();
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.broadcast" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#592-603">Source</a><h4 class="code-header">pub fn <a href="#method.broadcast" class="fn">broadcast</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(&amp;self, data: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>, root: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Broadcast a slice from root to all processes.</p>
<h5 id="arguments-6"><a class="doc-anchor" href="#arguments-6">§</a>Arguments</h5>
<ul>
<li><code>data</code> - Buffer to broadcast (input at root, output at others)</li>
<li><code>root</code> - Rank of the root process</li>
</ul>
<h5 id="example-11"><a class="doc-anchor" href="#example-11">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>data = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">100</span>];
<span class="kw">if </span>world.rank() == <span class="number">0 </span>{
    data.fill(<span class="number">42.0</span>);
}
world.broadcast(<span class="kw-2">&amp;mut </span>data, <span class="number">0</span>).unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reduce" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#624-646">Source</a><h4 class="code-header">pub fn <a href="#method.reduce" class="fn">reduce</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    op: <a class="enum" href="enum.ReduceOp.html" title="enum ferrompi::ReduceOp">ReduceOp</a>,
    root: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Reduce values to the root process.</p>
<h5 id="arguments-7"><a class="doc-anchor" href="#arguments-7">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Data to send from this process</li>
<li><code>recv</code> - Buffer for result (only significant at root)</li>
<li><code>op</code> - Reduction operation</li>
<li><code>root</code> - Rank of the root process</li>
</ul>
<h5 id="example-12"><a class="doc-anchor" href="#example-12">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>send = <span class="macro">vec!</span>[<span class="number">1.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">10</span>];
world.reduce(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, ReduceOp::Sum, <span class="number">0</span>).unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reduce_scalar" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#670-675">Source</a><h4 class="code-header">pub fn <a href="#method.reduce_scalar" class="fn">reduce_scalar</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    value: T,
    op: <a class="enum" href="enum.ReduceOp.html" title="enum ferrompi::ReduceOp">ReduceOp</a>,
    root: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Reduce a single scalar value to the root process.</p>
<p>Convenience method that wraps <a href="struct.Communicator.html#method.reduce" title="method ferrompi::Communicator::reduce"><code>reduce</code></a> for a single element.
The result is only meaningful at the root process.</p>
<h5 id="arguments-8"><a class="doc-anchor" href="#arguments-8">§</a>Arguments</h5>
<ul>
<li><code>value</code> - The scalar value to contribute from this process</li>
<li><code>op</code> - Reduction operation</li>
<li><code>root</code> - Rank of the root process</li>
</ul>
<h5 id="example-13"><a class="doc-anchor" href="#example-13">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>sum = world.reduce_scalar(world.rank() <span class="kw">as </span>f64, ReduceOp::Sum, <span class="number">0</span>).unwrap();
<span class="kw">if </span>world.rank() == <span class="number">0 </span>{
    <span class="macro">println!</span>(<span class="string">"Sum of all ranks: {sum}"</span>);
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reduce_inplace" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#704-723">Source</a><h4 class="code-header">pub fn <a href="#method.reduce_inplace" class="fn">reduce_inplace</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    data: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    op: <a class="enum" href="enum.ReduceOp.html" title="enum ferrompi::ReduceOp">ReduceOp</a>,
    root: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>In-place reduce to the root process.</p>
<p>At root: <code>data</code> is both input and output (the reduction result overwrites
the input).
At non-root: <code>data</code> is the send buffer only.</p>
<p>This avoids allocating a separate receive buffer at the root, which is
useful for large reductions where memory is a concern.</p>
<h5 id="arguments-9"><a class="doc-anchor" href="#arguments-9">§</a>Arguments</h5>
<ul>
<li><code>data</code> - Buffer to reduce (input on all ranks, output only at root)</li>
<li><code>op</code> - Reduction operation</li>
<li><code>root</code> - Rank of the root process</li>
</ul>
<h5 id="example-14"><a class="doc-anchor" href="#example-14">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>data = <span class="macro">vec!</span>[world.rank() <span class="kw">as </span>f64; <span class="number">10</span>];
world.reduce_inplace(<span class="kw-2">&amp;mut </span>data, ReduceOp::Sum, <span class="number">0</span>).unwrap();
<span class="kw">if </span>world.rank() == <span class="number">0 </span>{
    <span class="macro">println!</span>(<span class="string">"Reduced result: {:?}"</span>, <span class="kw-2">&amp;</span>data[..<span class="number">3</span>]);
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.allreduce" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#743-763">Source</a><h4 class="code-header">pub fn <a href="#method.allreduce" class="fn">allreduce</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    op: <a class="enum" href="enum.ReduceOp.html" title="enum ferrompi::ReduceOp">ReduceOp</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>All-reduce values (reduce and broadcast result to all).</p>
<h5 id="arguments-10"><a class="doc-anchor" href="#arguments-10">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Data to send from this process</li>
<li><code>recv</code> - Buffer for result</li>
<li><code>op</code> - Reduction operation</li>
</ul>
<h5 id="example-15"><a class="doc-anchor" href="#example-15">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>send = <span class="macro">vec!</span>[world.rank() <span class="kw">as </span>f64; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">10</span>];
world.allreduce(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, ReduceOp::Sum).unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.allreduce_inplace" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#776-787">Source</a><h4 class="code-header">pub fn <a href="#method.allreduce_inplace" class="fn">allreduce_inplace</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    data: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    op: <a class="enum" href="enum.ReduceOp.html" title="enum ferrompi::ReduceOp">ReduceOp</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>All-reduce values in place.</p>
<h5 id="example-16"><a class="doc-anchor" href="#example-16">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>data = <span class="macro">vec!</span>[world.rank() <span class="kw">as </span>f64; <span class="number">10</span>];
world.allreduce_inplace(<span class="kw-2">&amp;mut </span>data, ReduceOp::Sum).unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.allreduce_scalar" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#802-808">Source</a><h4 class="code-header">pub fn <a href="#method.allreduce_scalar" class="fn">allreduce_scalar</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    value: T,
    op: <a class="enum" href="enum.ReduceOp.html" title="enum ferrompi::ReduceOp">ReduceOp</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>All-reduce a single scalar value.</p>
<p>Convenience method for reducing a single element.</p>
<h5 id="example-17"><a class="doc-anchor" href="#example-17">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>sum = world.allreduce_scalar(world.rank() <span class="kw">as </span>f64, ReduceOp::Sum).unwrap();
<span class="macro">println!</span>(<span class="string">"Sum of all ranks: {sum}"</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.scan" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#837-852">Source</a><h4 class="code-header">pub fn <a href="#method.scan" class="fn">scan</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    op: <a class="enum" href="enum.ReduceOp.html" title="enum ferrompi::ReduceOp">ReduceOp</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Inclusive prefix reduction (scan).</p>
<p>On rank <code>i</code>, <code>recv</code> contains the reduction of <code>send</code> values from ranks
<code>0..=i</code>. This is the inclusive variant: every rank’s own contribution is
included in its result.</p>
<h5 id="arguments-11"><a class="doc-anchor" href="#arguments-11">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Data to contribute from this process</li>
<li><code>recv</code> - Buffer for the prefix-reduced result (must be same length as <code>send</code>)</li>
<li><code>op</code> - Reduction operation</li>
</ul>
<h5 id="errors-1"><a class="doc-anchor" href="#errors-1">§</a>Errors</h5>
<p>Returns <a href="enum.Error.html#variant.InvalidBuffer" title="variant ferrompi::Error::InvalidBuffer"><code>Error::InvalidBuffer</code></a> if <code>send.len() != recv.len()</code>.</p>
<h5 id="example-18"><a class="doc-anchor" href="#example-18">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>send = <span class="macro">vec!</span>[<span class="number">1.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">10</span>];
world.scan(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, ReduceOp::Sum).unwrap();
<span class="comment">// On rank i, recv[j] == (i + 1) * send[j]</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.exscan" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#887-902">Source</a><h4 class="code-header">pub fn <a href="#method.exscan" class="fn">exscan</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    op: <a class="enum" href="enum.ReduceOp.html" title="enum ferrompi::ReduceOp">ReduceOp</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Exclusive prefix reduction (exscan).</p>
<p>On rank <code>i</code>, <code>recv</code> contains the reduction of <code>send</code> values from ranks
<code>0..i</code> (i.e., excluding rank <code>i</code>’s own contribution).</p>
<h5 id="rank-0-behavior"><a class="doc-anchor" href="#rank-0-behavior">§</a>Rank 0 Behavior</h5>
<p><strong>Per the MPI standard, the contents of <code>recv</code> on rank 0 are undefined.</strong>
Callers must not rely on the receive buffer contents on rank 0.</p>
<h5 id="arguments-12"><a class="doc-anchor" href="#arguments-12">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Data to contribute from this process</li>
<li><code>recv</code> - Buffer for the prefix-reduced result (must be same length as <code>send</code>;
<strong>undefined on rank 0</strong>)</li>
<li><code>op</code> - Reduction operation</li>
</ul>
<h5 id="errors-2"><a class="doc-anchor" href="#errors-2">§</a>Errors</h5>
<p>Returns <a href="enum.Error.html#variant.InvalidBuffer" title="variant ferrompi::Error::InvalidBuffer"><code>Error::InvalidBuffer</code></a> if <code>send.len() != recv.len()</code>.</p>
<h5 id="example-19"><a class="doc-anchor" href="#example-19">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>send = <span class="macro">vec!</span>[<span class="number">1.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">10</span>];
world.exscan(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, ReduceOp::Sum).unwrap();
<span class="comment">// On rank i &gt; 0, recv[j] == i * send[j]
// On rank 0, recv is undefined per the MPI standard.</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.scan_scalar" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#918-923">Source</a><h4 class="code-header">pub fn <a href="#method.scan_scalar" class="fn">scan_scalar</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(&amp;self, value: T, op: <a class="enum" href="enum.ReduceOp.html" title="enum ferrompi::ReduceOp">ReduceOp</a>) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Inclusive scan of a single scalar value.</p>
<p>Convenience method for scanning a single element. On rank <code>i</code>, returns
the reduction of the input values from ranks <code>0..=i</code>.</p>
<h5 id="example-20"><a class="doc-anchor" href="#example-20">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>prefix_sum = world.scan_scalar(<span class="number">1.0f64</span>, ReduceOp::Sum).unwrap();
<span class="comment">// On rank i, prefix_sum == (i + 1) as f64</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.exscan_scalar" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#945-950">Source</a><h4 class="code-header">pub fn <a href="#method.exscan_scalar" class="fn">exscan_scalar</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(&amp;self, value: T, op: <a class="enum" href="enum.ReduceOp.html" title="enum ferrompi::ReduceOp">ReduceOp</a>) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Exclusive scan of a single scalar value.</p>
<p>Convenience method for exclusive-scanning a single element. On rank <code>i</code>,
returns the reduction of input values from ranks <code>0..i</code>.</p>
<h5 id="rank-0-behavior-1"><a class="doc-anchor" href="#rank-0-behavior-1">§</a>Rank 0 Behavior</h5>
<p><strong>Per the MPI standard, the return value on rank 0 is undefined.</strong>
Callers must not rely on the result on rank 0.</p>
<h5 id="example-21"><a class="doc-anchor" href="#example-21">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>prefix_sum = world.exscan_scalar(<span class="number">1.0f64</span>, ReduceOp::Sum).unwrap();
<span class="comment">// On rank i &gt; 0, prefix_sum == i as f64
// On rank 0, the result is undefined per the MPI standard.</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.gather" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#974-987">Source</a><h4 class="code-header">pub fn <a href="#method.gather" class="fn">gather</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    root: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Gather values to the root process.</p>
<p>Each process sends <code>send.len()</code> elements. Root receives
<code>send.len() * size</code> elements total.</p>
<h5 id="arguments-13"><a class="doc-anchor" href="#arguments-13">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Data to send from this process</li>
<li><code>recv</code> - Buffer for received data (only significant at root, must be
<code>send.len() * size</code> elements)</li>
<li><code>root</code> - Rank of the root process</li>
</ul>
<h5 id="example-22"><a class="doc-anchor" href="#example-22">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>send = <span class="macro">vec!</span>[world.rank() <span class="kw">as </span>f64; <span class="number">5</span>];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">5 </span>* world.size() <span class="kw">as </span>usize];
world.gather(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, <span class="number">0</span>).unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.allgather" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#1001-1013">Source</a><h4 class="code-header">pub fn <a href="#method.allgather" class="fn">allgather</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>All-gather values (gather and broadcast to all).</p>
<h5 id="example-23"><a class="doc-anchor" href="#example-23">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>send = <span class="macro">vec!</span>[world.rank() <span class="kw">as </span>i32; <span class="number">3</span>];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0i32</span>; <span class="number">3 </span>* world.size() <span class="kw">as </span>usize];
world.allgather(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv).unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.scatter" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#1030-1043">Source</a><h4 class="code-header">pub fn <a href="#method.scatter" class="fn">scatter</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    root: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Scatter values from root to all processes.</p>
<p>Root sends <code>recv.len() * size</code> elements total, each process receives
<code>recv.len()</code> elements.</p>
<h5 id="example-24"><a class="doc-anchor" href="#example-24">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>send = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">5 </span>* world.size() <span class="kw">as </span>usize];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">5</span>];
world.scatter(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, <span class="number">0</span>).unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.alltoall" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#1070-1087">Source</a><h4 class="code-header">pub fn <a href="#method.alltoall" class="fn">alltoall</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(&amp;self, send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>, recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>All-to-all personalized communication.</p>
<p>Each process sends <code>send.len() / size</code> elements to every other process
and receives the same amount from each.</p>
<p><code>send</code> must have exactly <code>count * size</code> elements, where <code>count</code>
is the number of elements sent to each process.
<code>recv</code> must have the same length as <code>send</code>.</p>
<h5 id="errors-3"><a class="doc-anchor" href="#errors-3">§</a>Errors</h5>
<p>Returns <a href="enum.Error.html#variant.InvalidBuffer" title="variant ferrompi::Error::InvalidBuffer"><code>Error::InvalidBuffer</code></a> if <code>send.len() != recv.len()</code> or
<code>send.len()</code> is not evenly divisible by the communicator size.</p>
<h5 id="example-25"><a class="doc-anchor" href="#example-25">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>size = world.size() <span class="kw">as </span>usize;
<span class="kw">let </span>send = <span class="macro">vec!</span>[world.rank() <span class="kw">as </span>f64; size * <span class="number">3</span>];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; size * <span class="number">3</span>];
world.alltoall(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv).unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reduce_scatter_block" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#1114-1135">Source</a><h4 class="code-header">pub fn <a href="#method.reduce_scatter_block" class="fn">reduce_scatter_block</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    op: <a class="enum" href="enum.ReduceOp.html" title="enum ferrompi::ReduceOp">ReduceOp</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Reduce-scatter with uniform block size.</p>
<p>Performs an element-wise reduction across all processes, then scatters
the result so that each process receives <code>recv.len()</code> elements.
<code>send</code> must have exactly <code>recv.len() * size</code> elements.</p>
<p>This is equivalent to <a href="struct.Communicator.html#method.allreduce" title="method ferrompi::Communicator::allreduce"><code>allreduce</code></a> followed by each
process keeping only its portion, but is more efficient because the MPI
implementation can fuse the two operations.</p>
<h5 id="errors-4"><a class="doc-anchor" href="#errors-4">§</a>Errors</h5>
<p>Returns <a href="enum.Error.html#variant.InvalidBuffer" title="variant ferrompi::Error::InvalidBuffer"><code>Error::InvalidBuffer</code></a> if <code>send.len() != recv.len() * size</code>.</p>
<h5 id="example-26"><a class="doc-anchor" href="#example-26">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>size = world.size() <span class="kw">as </span>usize;
<span class="kw">let </span>send = <span class="macro">vec!</span>[<span class="number">1.0f64</span>; size * <span class="number">5</span>];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">5</span>];
world.reduce_scatter_block(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, ReduceOp::Sum).unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.gatherv" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#1174-1195">Source</a><h4 class="code-header">pub fn <a href="#method.gatherv" class="fn">gatherv</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recvcounts: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
    displs: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
    root: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Gather variable amounts of data to the root process.</p>
<p>Each process sends <code>send.len()</code> elements. At the root, <code>recvcounts[i]</code>
elements are placed at offset <code>displs[i]</code> in <code>recv</code> from rank <code>i</code>.
Both <code>recvcounts</code> and <code>displs</code> must have length equal to the
communicator size and are only significant at root.</p>
<h5 id="arguments-14"><a class="doc-anchor" href="#arguments-14">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Data to send from this process</li>
<li><code>recv</code> - Buffer for received data (only significant at root)</li>
<li><code>recvcounts</code> - Number of elements received from each rank</li>
<li><code>displs</code> - Displacement in <code>recv</code> for data from each rank</li>
<li><code>root</code> - Rank of the root process</li>
</ul>
<h5 id="example-27"><a class="doc-anchor" href="#example-27">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>rank = world.rank();
<span class="comment">// Each rank sends (rank+1) elements
</span><span class="kw">let </span>send = <span class="macro">vec!</span>[rank <span class="kw">as </span>f64; (rank + <span class="number">1</span>) <span class="kw">as </span>usize];
<span class="kw">let </span>size = world.size();
<span class="kw">let </span>recvcounts: Vec&lt;i32&gt; = (<span class="number">0</span>..size).map(|r| r + <span class="number">1</span>).collect();
<span class="kw">let </span>displs: Vec&lt;i32&gt; = recvcounts.iter()
    .scan(<span class="number">0</span>, |acc, <span class="kw-2">&amp;</span>c| { <span class="kw">let </span>d = <span class="kw-2">*</span>acc; <span class="kw-2">*</span>acc += c; <span class="prelude-val">Some</span>(d) })
    .collect();
<span class="kw">let </span>total: i32 = recvcounts.iter().sum();
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; total <span class="kw">as </span>usize];
world.gatherv(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, <span class="kw-2">&amp;</span>recvcounts, <span class="kw-2">&amp;</span>displs, <span class="number">0</span>).unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.scatterv" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#1229-1250">Source</a><h4 class="code-header">pub fn <a href="#method.scatterv" class="fn">scatterv</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    sendcounts: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
    displs: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    root: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Scatter variable amounts of data from the root process.</p>
<p>At the root, <code>sendcounts[i]</code> elements starting at offset <code>displs[i]</code>
in <code>send</code> are sent to rank <code>i</code>. Each process receives <code>recv.len()</code>
elements. Both <code>sendcounts</code> and <code>displs</code> must have length equal to
the communicator size and are only significant at root.</p>
<h5 id="arguments-15"><a class="doc-anchor" href="#arguments-15">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Data to scatter (only significant at root)</li>
<li><code>sendcounts</code> - Number of elements sent to each rank</li>
<li><code>displs</code> - Displacement in <code>send</code> for data to each rank</li>
<li><code>recv</code> - Buffer for received data</li>
<li><code>root</code> - Rank of the root process</li>
</ul>
<h5 id="example-28"><a class="doc-anchor" href="#example-28">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>rank = world.rank();
<span class="kw">let </span>size = world.size();
<span class="kw">let </span>sendcounts: Vec&lt;i32&gt; = (<span class="number">0</span>..size).map(|r| r + <span class="number">1</span>).collect();
<span class="kw">let </span>displs: Vec&lt;i32&gt; = sendcounts.iter()
    .scan(<span class="number">0</span>, |acc, <span class="kw-2">&amp;</span>c| { <span class="kw">let </span>d = <span class="kw-2">*</span>acc; <span class="kw-2">*</span>acc += c; <span class="prelude-val">Some</span>(d) })
    .collect();
<span class="kw">let </span>total: i32 = sendcounts.iter().sum();
<span class="kw">let </span>send = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; total <span class="kw">as </span>usize];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; (rank + <span class="number">1</span>) <span class="kw">as </span>usize];
world.scatterv(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;</span>sendcounts, <span class="kw-2">&amp;</span>displs, <span class="kw-2">&amp;mut </span>recv, <span class="number">0</span>).unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.allgatherv" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#1283-1302">Source</a><h4 class="code-header">pub fn <a href="#method.allgatherv" class="fn">allgatherv</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recvcounts: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
    displs: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>All-gather variable amounts of data (gather and broadcast to all).</p>
<p>Each process sends <code>send.len()</code> elements. In <code>recv</code>, <code>recvcounts[i]</code>
elements from rank <code>i</code> are placed at offset <code>displs[i]</code>. Both
<code>recvcounts</code> and <code>displs</code> must have length equal to the communicator
size.</p>
<h5 id="arguments-16"><a class="doc-anchor" href="#arguments-16">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Data to send from this process</li>
<li><code>recv</code> - Buffer for received data</li>
<li><code>recvcounts</code> - Number of elements received from each rank</li>
<li><code>displs</code> - Displacement in <code>recv</code> for data from each rank</li>
</ul>
<h5 id="example-29"><a class="doc-anchor" href="#example-29">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>rank = world.rank();
<span class="kw">let </span>size = world.size();
<span class="kw">let </span>send = <span class="macro">vec!</span>[rank <span class="kw">as </span>f64; (rank + <span class="number">1</span>) <span class="kw">as </span>usize];
<span class="kw">let </span>recvcounts: Vec&lt;i32&gt; = (<span class="number">0</span>..size).map(|r| r + <span class="number">1</span>).collect();
<span class="kw">let </span>displs: Vec&lt;i32&gt; = recvcounts.iter()
    .scan(<span class="number">0</span>, |acc, <span class="kw-2">&amp;</span>c| { <span class="kw">let </span>d = <span class="kw-2">*</span>acc; <span class="kw-2">*</span>acc += c; <span class="prelude-val">Some</span>(d) })
    .collect();
<span class="kw">let </span>total: i32 = recvcounts.iter().sum();
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; total <span class="kw">as </span>usize];
world.allgatherv(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, <span class="kw-2">&amp;</span>recvcounts, <span class="kw-2">&amp;</span>displs).unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.alltoallv" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#1335-1357">Source</a><h4 class="code-header">pub fn <a href="#method.alltoallv" class="fn">alltoallv</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    sendcounts: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
    sdispls: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recvcounts: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
    rdispls: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>All-to-all with variable counts.</p>
<p>Each process sends <code>sendcounts[i]</code> elements starting at offset
<code>sdispls[i]</code> in <code>send</code> to rank <code>i</code>, and receives <code>recvcounts[i]</code>
elements from rank <code>i</code> at offset <code>rdispls[i]</code> in <code>recv</code>. All four
arrays must have length equal to the communicator size.</p>
<h5 id="arguments-17"><a class="doc-anchor" href="#arguments-17">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Send buffer</li>
<li><code>sendcounts</code> - Number of elements to send to each rank</li>
<li><code>sdispls</code> - Send displacement for each rank</li>
<li><code>recv</code> - Receive buffer</li>
<li><code>recvcounts</code> - Number of elements to receive from each rank</li>
<li><code>rdispls</code> - Receive displacement for each rank</li>
</ul>
<h5 id="example-30"><a class="doc-anchor" href="#example-30">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>size = world.size() <span class="kw">as </span>usize;
<span class="kw">let </span>sendcounts = <span class="macro">vec!</span>[<span class="number">1i32</span>; size];
<span class="kw">let </span>sdispls: Vec&lt;i32&gt; = (<span class="number">0</span>..size <span class="kw">as </span>i32).collect();
<span class="kw">let </span>recvcounts = <span class="macro">vec!</span>[<span class="number">1i32</span>; size];
<span class="kw">let </span>rdispls: Vec&lt;i32&gt; = (<span class="number">0</span>..size <span class="kw">as </span>i32).collect();
<span class="kw">let </span>send = <span class="macro">vec!</span>[world.rank() <span class="kw">as </span>f64; size];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; size];
world.alltoallv(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;</span>sendcounts, <span class="kw-2">&amp;</span>sdispls, <span class="kw-2">&amp;mut </span>recv, <span class="kw-2">&amp;</span>recvcounts, <span class="kw-2">&amp;</span>rdispls).unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.ibroadcast" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#1382-1396">Source</a><h4 class="code-header">pub fn <a href="#method.ibroadcast" class="fn">ibroadcast</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    data: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    root: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.Request.html" title="struct ferrompi::Request">Request</a>&gt;</h4></section></summary><div class="docblock"><p>Nonblocking broadcast.</p>
<p>Returns a request handle that must be waited on before accessing the buffer.</p>
<h5 id="safety-note"><a class="doc-anchor" href="#safety-note">§</a>Safety Note</h5>
<p>The buffer must remain valid until the request is completed.</p>
<h5 id="example-31"><a class="doc-anchor" href="#example-31">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>data = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">100</span>];
<span class="kw">let </span>req = world.ibroadcast(<span class="kw-2">&amp;mut </span>data, <span class="number">0</span>).unwrap();
<span class="comment">// ... do other work ...
</span>req.wait().unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.iallreduce" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#1413-1436">Source</a><h4 class="code-header">pub fn <a href="#method.iallreduce" class="fn">iallreduce</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    op: <a class="enum" href="enum.ReduceOp.html" title="enum ferrompi::ReduceOp">ReduceOp</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.Request.html" title="struct ferrompi::Request">Request</a>&gt;</h4></section></summary><div class="docblock"><p>Nonblocking all-reduce.</p>
<p>Returns a request handle that must be waited on before accessing the buffer.</p>
<h5 id="example-32"><a class="doc-anchor" href="#example-32">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>send = <span class="macro">vec!</span>[<span class="number">1.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span>req = world.iallreduce(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, ReduceOp::Sum).unwrap();
req.wait().unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.ireduce" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#1461-1486">Source</a><h4 class="code-header">pub fn <a href="#method.ireduce" class="fn">ireduce</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    op: <a class="enum" href="enum.ReduceOp.html" title="enum ferrompi::ReduceOp">ReduceOp</a>,
    root: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.Request.html" title="struct ferrompi::Request">Request</a>&gt;</h4></section></summary><div class="docblock"><p>Nonblocking reduce to root.</p>
<p>Initiates a reduction operation and returns immediately with a <a href="struct.Request.html" title="struct ferrompi::Request"><code>Request</code></a>
handle. The buffers must remain valid until the request is completed.</p>
<h5 id="arguments-18"><a class="doc-anchor" href="#arguments-18">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Data to send from this process</li>
<li><code>recv</code> - Buffer for result (only significant at root)</li>
<li><code>op</code> - Reduction operation</li>
<li><code>root</code> - Rank of the root process</li>
</ul>
<h5 id="example-33"><a class="doc-anchor" href="#example-33">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>send = <span class="macro">vec!</span>[<span class="number">1.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span>req = world.ireduce(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, ReduceOp::Sum, <span class="number">0</span>).unwrap();
req.wait().unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.igather" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#1511-1532">Source</a><h4 class="code-header">pub fn <a href="#method.igather" class="fn">igather</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    root: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.Request.html" title="struct ferrompi::Request">Request</a>&gt;</h4></section></summary><div class="docblock"><p>Nonblocking gather to root.</p>
<p>Initiates a gather operation and returns immediately with a <a href="struct.Request.html" title="struct ferrompi::Request"><code>Request</code></a>
handle. Each process sends <code>send.len()</code> elements. Root receives
<code>send.len() * size</code> elements total.</p>
<h5 id="arguments-19"><a class="doc-anchor" href="#arguments-19">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Data to send from this process</li>
<li><code>recv</code> - Buffer for received data (only significant at root)</li>
<li><code>root</code> - Rank of the root process</li>
</ul>
<h5 id="example-34"><a class="doc-anchor" href="#example-34">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>send = <span class="macro">vec!</span>[world.rank() <span class="kw">as </span>f64; <span class="number">5</span>];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">5 </span>* world.size() <span class="kw">as </span>usize];
<span class="kw">let </span>req = world.igather(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, <span class="number">0</span>).unwrap();
req.wait().unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.iallgather" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#1551-1566">Source</a><h4 class="code-header">pub fn <a href="#method.iallgather" class="fn">iallgather</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.Request.html" title="struct ferrompi::Request">Request</a>&gt;</h4></section></summary><div class="docblock"><p>Nonblocking all-gather.</p>
<p>Initiates an all-gather operation and returns immediately with a
<a href="struct.Request.html" title="struct ferrompi::Request"><code>Request</code></a> handle. Each process sends <code>send.len()</code> elements and
receives from all.</p>
<h5 id="example-35"><a class="doc-anchor" href="#example-35">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>send = <span class="macro">vec!</span>[world.rank() <span class="kw">as </span>i32; <span class="number">3</span>];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0i32</span>; <span class="number">3 </span>* world.size() <span class="kw">as </span>usize];
<span class="kw">let </span>req = world.iallgather(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv).unwrap();
req.wait().unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.iscatter" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#1585-1606">Source</a><h4 class="code-header">pub fn <a href="#method.iscatter" class="fn">iscatter</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    root: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.Request.html" title="struct ferrompi::Request">Request</a>&gt;</h4></section></summary><div class="docblock"><p>Nonblocking scatter from root.</p>
<p>Initiates a scatter operation and returns immediately with a <a href="struct.Request.html" title="struct ferrompi::Request"><code>Request</code></a>
handle. Root sends <code>recv.len() * size</code> elements total, each process
receives <code>recv.len()</code> elements.</p>
<h5 id="example-36"><a class="doc-anchor" href="#example-36">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>send = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">5 </span>* world.size() <span class="kw">as </span>usize];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">5</span>];
<span class="kw">let </span>req = world.iscatter(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, <span class="number">0</span>).unwrap();
req.wait().unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.ibarrier" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#1623-1628">Source</a><h4 class="code-header">pub fn <a href="#method.ibarrier" class="fn">ibarrier</a>(&amp;self) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.Request.html" title="struct ferrompi::Request">Request</a>&gt;</h4></section></summary><div class="docblock"><p>Nonblocking barrier.</p>
<p>Initiates a barrier synchronization and returns immediately with a
<a href="struct.Request.html" title="struct ferrompi::Request"><code>Request</code></a> handle. The barrier is complete when the request is waited on.</p>
<h5 id="example-37"><a class="doc-anchor" href="#example-37">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>req = world.ibarrier().unwrap();
<span class="comment">// ... do other work ...
</span>req.wait().unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.iscan" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#1651-1674">Source</a><h4 class="code-header">pub fn <a href="#method.iscan" class="fn">iscan</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    op: <a class="enum" href="enum.ReduceOp.html" title="enum ferrompi::ReduceOp">ReduceOp</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.Request.html" title="struct ferrompi::Request">Request</a>&gt;</h4></section></summary><div class="docblock"><p>Nonblocking inclusive prefix reduction (scan).</p>
<p>Initiates an inclusive scan and returns immediately with a <a href="struct.Request.html" title="struct ferrompi::Request"><code>Request</code></a>
handle. On rank <code>i</code>, <code>recv</code> will contain the reduction of <code>send</code> values
from ranks <code>0..=i</code> once the request completes.</p>
<h5 id="errors-5"><a class="doc-anchor" href="#errors-5">§</a>Errors</h5>
<p>Returns <a href="enum.Error.html#variant.InvalidBuffer" title="variant ferrompi::Error::InvalidBuffer"><code>Error::InvalidBuffer</code></a> if <code>send.len() != recv.len()</code>.</p>
<h5 id="example-38"><a class="doc-anchor" href="#example-38">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>send = <span class="macro">vec!</span>[<span class="number">1.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span>req = world.iscan(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, ReduceOp::Sum).unwrap();
req.wait().unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.iexscan" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#1701-1724">Source</a><h4 class="code-header">pub fn <a href="#method.iexscan" class="fn">iexscan</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    op: <a class="enum" href="enum.ReduceOp.html" title="enum ferrompi::ReduceOp">ReduceOp</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.Request.html" title="struct ferrompi::Request">Request</a>&gt;</h4></section></summary><div class="docblock"><p>Nonblocking exclusive prefix reduction (exscan).</p>
<p>Initiates an exclusive scan and returns immediately with a <a href="struct.Request.html" title="struct ferrompi::Request"><code>Request</code></a>
handle. On rank <code>i</code>, <code>recv</code> will contain the reduction of <code>send</code> values
from ranks <code>0..i</code> once the request completes.</p>
<h5 id="rank-0-behavior-2"><a class="doc-anchor" href="#rank-0-behavior-2">§</a>Rank 0 Behavior</h5>
<p><strong>Per the MPI standard, the contents of <code>recv</code> on rank 0 are undefined.</strong></p>
<h5 id="errors-6"><a class="doc-anchor" href="#errors-6">§</a>Errors</h5>
<p>Returns <a href="enum.Error.html#variant.InvalidBuffer" title="variant ferrompi::Error::InvalidBuffer"><code>Error::InvalidBuffer</code></a> if <code>send.len() != recv.len()</code>.</p>
<h5 id="example-39"><a class="doc-anchor" href="#example-39">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>send = <span class="macro">vec!</span>[<span class="number">1.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span>req = world.iexscan(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, ReduceOp::Sum).unwrap();
req.wait().unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.ialltoall" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#1748-1768">Source</a><h4 class="code-header">pub fn <a href="#method.ialltoall" class="fn">ialltoall</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.Request.html" title="struct ferrompi::Request">Request</a>&gt;</h4></section></summary><div class="docblock"><p>Nonblocking all-to-all personalized communication.</p>
<p>Initiates an all-to-all operation and returns immediately with a
<a href="struct.Request.html" title="struct ferrompi::Request"><code>Request</code></a> handle.</p>
<h5 id="errors-7"><a class="doc-anchor" href="#errors-7">§</a>Errors</h5>
<p>Returns <a href="enum.Error.html#variant.InvalidBuffer" title="variant ferrompi::Error::InvalidBuffer"><code>Error::InvalidBuffer</code></a> if <code>send.len() != recv.len()</code> or
<code>send.len()</code> is not evenly divisible by the communicator size.</p>
<h5 id="example-40"><a class="doc-anchor" href="#example-40">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>size = world.size() <span class="kw">as </span>usize;
<span class="kw">let </span>send = <span class="macro">vec!</span>[world.rank() <span class="kw">as </span>f64; size * <span class="number">3</span>];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; size * <span class="number">3</span>];
<span class="kw">let </span>req = world.ialltoall(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv).unwrap();
req.wait().unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.igatherv" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#1801-1825">Source</a><h4 class="code-header">pub fn <a href="#method.igatherv" class="fn">igatherv</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recvcounts: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
    displs: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
    root: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.Request.html" title="struct ferrompi::Request">Request</a>&gt;</h4></section></summary><div class="docblock"><p>Nonblocking gather variable amounts of data to root.</p>
<p>Initiates a variable-count gather and returns immediately with a
<a href="struct.Request.html" title="struct ferrompi::Request"><code>Request</code></a> handle.</p>
<h5 id="arguments-20"><a class="doc-anchor" href="#arguments-20">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Data to send from this process</li>
<li><code>recv</code> - Buffer for received data (only significant at root)</li>
<li><code>recvcounts</code> - Number of elements received from each rank</li>
<li><code>displs</code> - Displacement in <code>recv</code> for data from each rank</li>
<li><code>root</code> - Rank of the root process</li>
</ul>
<h5 id="example-41"><a class="doc-anchor" href="#example-41">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>rank = world.rank();
<span class="kw">let </span>send = <span class="macro">vec!</span>[rank <span class="kw">as </span>f64; (rank + <span class="number">1</span>) <span class="kw">as </span>usize];
<span class="kw">let </span>size = world.size();
<span class="kw">let </span>recvcounts: Vec&lt;i32&gt; = (<span class="number">0</span>..size).map(|r| r + <span class="number">1</span>).collect();
<span class="kw">let </span>displs: Vec&lt;i32&gt; = recvcounts.iter()
    .scan(<span class="number">0</span>, |acc, <span class="kw-2">&amp;</span>c| { <span class="kw">let </span>d = <span class="kw-2">*</span>acc; <span class="kw-2">*</span>acc += c; <span class="prelude-val">Some</span>(d) })
    .collect();
<span class="kw">let </span>total: i32 = recvcounts.iter().sum();
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; total <span class="kw">as </span>usize];
<span class="kw">let </span>req = world.igatherv(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, <span class="kw-2">&amp;</span>recvcounts, <span class="kw-2">&amp;</span>displs, <span class="number">0</span>).unwrap();
req.wait().unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.iscatterv" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#1858-1882">Source</a><h4 class="code-header">pub fn <a href="#method.iscatterv" class="fn">iscatterv</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    sendcounts: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
    displs: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
    root: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.Request.html" title="struct ferrompi::Request">Request</a>&gt;</h4></section></summary><div class="docblock"><p>Nonblocking scatter variable amounts of data from root.</p>
<p>Initiates a variable-count scatter and returns immediately with a
<a href="struct.Request.html" title="struct ferrompi::Request"><code>Request</code></a> handle.</p>
<h5 id="arguments-21"><a class="doc-anchor" href="#arguments-21">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Data to scatter (only significant at root)</li>
<li><code>recv</code> - Buffer for received data</li>
<li><code>sendcounts</code> - Number of elements sent to each rank</li>
<li><code>displs</code> - Displacement in <code>send</code> for data to each rank</li>
<li><code>root</code> - Rank of the root process</li>
</ul>
<h5 id="example-42"><a class="doc-anchor" href="#example-42">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>rank = world.rank();
<span class="kw">let </span>size = world.size();
<span class="kw">let </span>sendcounts: Vec&lt;i32&gt; = (<span class="number">0</span>..size).map(|r| r + <span class="number">1</span>).collect();
<span class="kw">let </span>displs: Vec&lt;i32&gt; = sendcounts.iter()
    .scan(<span class="number">0</span>, |acc, <span class="kw-2">&amp;</span>c| { <span class="kw">let </span>d = <span class="kw-2">*</span>acc; <span class="kw-2">*</span>acc += c; <span class="prelude-val">Some</span>(d) })
    .collect();
<span class="kw">let </span>total: i32 = sendcounts.iter().sum();
<span class="kw">let </span>send = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; total <span class="kw">as </span>usize];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; (rank + <span class="number">1</span>) <span class="kw">as </span>usize];
<span class="kw">let </span>req = world.iscatterv(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, <span class="kw-2">&amp;</span>sendcounts, <span class="kw-2">&amp;</span>displs, <span class="number">0</span>).unwrap();
req.wait().unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.iallgatherv" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#1914-1936">Source</a><h4 class="code-header">pub fn <a href="#method.iallgatherv" class="fn">iallgatherv</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recvcounts: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
    displs: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.Request.html" title="struct ferrompi::Request">Request</a>&gt;</h4></section></summary><div class="docblock"><p>Nonblocking all-gather variable amounts of data.</p>
<p>Initiates a variable-count all-gather and returns immediately with a
<a href="struct.Request.html" title="struct ferrompi::Request"><code>Request</code></a> handle.</p>
<h5 id="arguments-22"><a class="doc-anchor" href="#arguments-22">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Data to send from this process</li>
<li><code>recv</code> - Buffer for received data</li>
<li><code>recvcounts</code> - Number of elements received from each rank</li>
<li><code>displs</code> - Displacement in <code>recv</code> for data from each rank</li>
</ul>
<h5 id="example-43"><a class="doc-anchor" href="#example-43">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>rank = world.rank();
<span class="kw">let </span>size = world.size();
<span class="kw">let </span>send = <span class="macro">vec!</span>[rank <span class="kw">as </span>f64; (rank + <span class="number">1</span>) <span class="kw">as </span>usize];
<span class="kw">let </span>recvcounts: Vec&lt;i32&gt; = (<span class="number">0</span>..size).map(|r| r + <span class="number">1</span>).collect();
<span class="kw">let </span>displs: Vec&lt;i32&gt; = recvcounts.iter()
    .scan(<span class="number">0</span>, |acc, <span class="kw-2">&amp;</span>c| { <span class="kw">let </span>d = <span class="kw-2">*</span>acc; <span class="kw-2">*</span>acc += c; <span class="prelude-val">Some</span>(d) })
    .collect();
<span class="kw">let </span>total: i32 = recvcounts.iter().sum();
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; total <span class="kw">as </span>usize];
<span class="kw">let </span>req = world.iallgatherv(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, <span class="kw-2">&amp;</span>recvcounts, <span class="kw-2">&amp;</span>displs).unwrap();
req.wait().unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.ialltoallv" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#1968-1993">Source</a><h4 class="code-header">pub fn <a href="#method.ialltoallv" class="fn">ialltoallv</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    sendcounts: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
    sdispls: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
    recvcounts: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
    rdispls: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.Request.html" title="struct ferrompi::Request">Request</a>&gt;</h4></section></summary><div class="docblock"><p>Nonblocking all-to-all with variable counts.</p>
<p>Initiates a variable-count all-to-all and returns immediately with a
<a href="struct.Request.html" title="struct ferrompi::Request"><code>Request</code></a> handle.</p>
<h5 id="arguments-23"><a class="doc-anchor" href="#arguments-23">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Send buffer</li>
<li><code>recv</code> - Receive buffer</li>
<li><code>sendcounts</code> - Number of elements to send to each rank</li>
<li><code>sdispls</code> - Send displacement for each rank</li>
<li><code>recvcounts</code> - Number of elements to receive from each rank</li>
<li><code>rdispls</code> - Receive displacement for each rank</li>
</ul>
<h5 id="example-44"><a class="doc-anchor" href="#example-44">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>size = world.size() <span class="kw">as </span>usize;
<span class="kw">let </span>sendcounts = <span class="macro">vec!</span>[<span class="number">1i32</span>; size];
<span class="kw">let </span>sdispls: Vec&lt;i32&gt; = (<span class="number">0</span>..size <span class="kw">as </span>i32).collect();
<span class="kw">let </span>recvcounts = <span class="macro">vec!</span>[<span class="number">1i32</span>; size];
<span class="kw">let </span>rdispls: Vec&lt;i32&gt; = (<span class="number">0</span>..size <span class="kw">as </span>i32).collect();
<span class="kw">let </span>send = <span class="macro">vec!</span>[world.rank() <span class="kw">as </span>f64; size];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; size];
<span class="kw">let </span>req = world.ialltoallv(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, <span class="kw-2">&amp;</span>sendcounts, <span class="kw-2">&amp;</span>sdispls, <span class="kw-2">&amp;</span>recvcounts, <span class="kw-2">&amp;</span>rdispls).unwrap();
req.wait().unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.ireduce_scatter_block" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#2018-2042">Source</a><h4 class="code-header">pub fn <a href="#method.ireduce_scatter_block" class="fn">ireduce_scatter_block</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    op: <a class="enum" href="enum.ReduceOp.html" title="enum ferrompi::ReduceOp">ReduceOp</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.Request.html" title="struct ferrompi::Request">Request</a>&gt;</h4></section></summary><div class="docblock"><p>Nonblocking reduce-scatter with uniform block size.</p>
<p>Initiates a reduce-scatter operation and returns immediately with a
<a href="struct.Request.html" title="struct ferrompi::Request"><code>Request</code></a> handle. Performs an element-wise reduction across all
processes, then scatters the result so that each process receives
<code>recv.len()</code> elements.</p>
<h5 id="errors-8"><a class="doc-anchor" href="#errors-8">§</a>Errors</h5>
<p>Returns <a href="enum.Error.html#variant.InvalidBuffer" title="variant ferrompi::Error::InvalidBuffer"><code>Error::InvalidBuffer</code></a> if <code>send.len() != recv.len() * size</code>.</p>
<h5 id="example-45"><a class="doc-anchor" href="#example-45">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>size = world.size() <span class="kw">as </span>usize;
<span class="kw">let </span>send = <span class="macro">vec!</span>[<span class="number">1.0f64</span>; size * <span class="number">5</span>];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">5</span>];
<span class="kw">let </span>req = world.ireduce_scatter_block(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, ReduceOp::Sum).unwrap();
req.wait().unwrap();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bcast_init" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#2071-2093">Source</a><h4 class="code-header">pub fn <a href="#method.bcast_init" class="fn">bcast_init</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    data: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    root: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.PersistentRequest.html" title="struct ferrompi::PersistentRequest">PersistentRequest</a>&gt;</h4></section></summary><div class="docblock"><p>Initialize a persistent broadcast operation.</p>
<p>The returned handle can be started multiple times with <code>start()</code>.
Requires MPI 4.0+.</p>
<h5 id="arguments-24"><a class="doc-anchor" href="#arguments-24">§</a>Arguments</h5>
<ul>
<li><code>data</code> - Buffer to use for broadcasts (must remain valid for lifetime of handle)</li>
<li><code>root</code> - Rank of the root process</li>
</ul>
<h5 id="example-46"><a class="doc-anchor" href="#example-46">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>data = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">100</span>];
<span class="kw">let </span><span class="kw-2">mut </span>persistent = world.bcast_init(<span class="kw-2">&amp;mut </span>data, <span class="number">0</span>).unwrap();
<span class="kw">for _ in </span><span class="number">0</span>..<span class="number">100 </span>{
    persistent.start().unwrap();
    persistent.wait().unwrap();
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.allreduce_init" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#2113-2140">Source</a><h4 class="code-header">pub fn <a href="#method.allreduce_init" class="fn">allreduce_init</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    op: <a class="enum" href="enum.ReduceOp.html" title="enum ferrompi::ReduceOp">ReduceOp</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.PersistentRequest.html" title="struct ferrompi::PersistentRequest">PersistentRequest</a>&gt;</h4></section></summary><div class="docblock"><p>Initialize a persistent all-reduce operation.</p>
<p>Requires MPI 4.0+.</p>
<h5 id="example-47"><a class="doc-anchor" href="#example-47">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>send = <span class="macro">vec!</span>[<span class="number">1.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>persistent = world.allreduce_init(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, ReduceOp::Sum).unwrap();
<span class="kw">for _ in </span><span class="number">0</span>..<span class="number">100 </span>{
    persistent.start().unwrap();
    persistent.wait().unwrap();
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.allreduce_init_inplace" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#2145-2167">Source</a><h4 class="code-header">pub fn <a href="#method.allreduce_init_inplace" class="fn">allreduce_init_inplace</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    data: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    op: <a class="enum" href="enum.ReduceOp.html" title="enum ferrompi::ReduceOp">ReduceOp</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.PersistentRequest.html" title="struct ferrompi::PersistentRequest">PersistentRequest</a>&gt;</h4></section></summary><div class="docblock"><p>Initialize a persistent in-place all-reduce operation.</p>
<p>Requires MPI 4.0+.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.gather_init" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#2172-2197">Source</a><h4 class="code-header">pub fn <a href="#method.gather_init" class="fn">gather_init</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    root: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.PersistentRequest.html" title="struct ferrompi::PersistentRequest">PersistentRequest</a>&gt;</h4></section></summary><div class="docblock"><p>Initialize a persistent gather operation.</p>
<p>Requires MPI 4.0+.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reduce_init" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#2225-2254">Source</a><h4 class="code-header">pub fn <a href="#method.reduce_init" class="fn">reduce_init</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    op: <a class="enum" href="enum.ReduceOp.html" title="enum ferrompi::ReduceOp">ReduceOp</a>,
    root: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.PersistentRequest.html" title="struct ferrompi::PersistentRequest">PersistentRequest</a>&gt;</h4></section></summary><div class="docblock"><p>Initialize a persistent reduce operation.</p>
<p>The returned handle can be started multiple times with <code>start()</code>.
Requires MPI 4.0+.</p>
<h5 id="arguments-25"><a class="doc-anchor" href="#arguments-25">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Send buffer</li>
<li><code>recv</code> - Receive buffer (significant only at root)</li>
<li><code>op</code> - Reduction operation</li>
<li><code>root</code> - Rank of the root process</li>
</ul>
<h5 id="example-48"><a class="doc-anchor" href="#example-48">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>send = <span class="macro">vec!</span>[<span class="number">1.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>persistent = world.reduce_init(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, ReduceOp::Sum, <span class="number">0</span>).unwrap();
<span class="kw">for _ in </span><span class="number">0</span>..<span class="number">100 </span>{
    persistent.start().unwrap();
    persistent.wait().unwrap();
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.scatter_init" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#2281-2306">Source</a><h4 class="code-header">pub fn <a href="#method.scatter_init" class="fn">scatter_init</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    root: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.PersistentRequest.html" title="struct ferrompi::PersistentRequest">PersistentRequest</a>&gt;</h4></section></summary><div class="docblock"><p>Initialize a persistent scatter operation.</p>
<p>The returned handle can be started multiple times with <code>start()</code>.
Requires MPI 4.0+.</p>
<h5 id="arguments-26"><a class="doc-anchor" href="#arguments-26">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Send buffer (significant only at root)</li>
<li><code>recv</code> - Receive buffer</li>
<li><code>root</code> - Rank of the root process</li>
</ul>
<h5 id="example-49"><a class="doc-anchor" href="#example-49">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>send = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">40</span>]; <span class="comment">// 4 ranks × 10 elements
</span><span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>persistent = world.scatter_init(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, <span class="number">0</span>).unwrap();
<span class="kw">for _ in </span><span class="number">0</span>..<span class="number">100 </span>{
    persistent.start().unwrap();
    persistent.wait().unwrap();
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.allgather_init" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#2332-2355">Source</a><h4 class="code-header">pub fn <a href="#method.allgather_init" class="fn">allgather_init</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.PersistentRequest.html" title="struct ferrompi::PersistentRequest">PersistentRequest</a>&gt;</h4></section></summary><div class="docblock"><p>Initialize a persistent all-gather operation.</p>
<p>The returned handle can be started multiple times with <code>start()</code>.
Requires MPI 4.0+.</p>
<h5 id="arguments-27"><a class="doc-anchor" href="#arguments-27">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Send buffer (each rank sends <code>send.len()</code> elements)</li>
<li><code>recv</code> - Receive buffer (must hold <code>send.len() * size</code> elements)</li>
</ul>
<h5 id="example-50"><a class="doc-anchor" href="#example-50">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>send = <span class="macro">vec!</span>[<span class="number">1.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">40</span>]; <span class="comment">// 4 ranks × 10
</span><span class="kw">let </span><span class="kw-2">mut </span>persistent = world.allgather_init(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv).unwrap();
<span class="kw">for _ in </span><span class="number">0</span>..<span class="number">100 </span>{
    persistent.start().unwrap();
    persistent.wait().unwrap();
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.scan_init" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#2382-2409">Source</a><h4 class="code-header">pub fn <a href="#method.scan_init" class="fn">scan_init</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    op: <a class="enum" href="enum.ReduceOp.html" title="enum ferrompi::ReduceOp">ReduceOp</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.PersistentRequest.html" title="struct ferrompi::PersistentRequest">PersistentRequest</a>&gt;</h4></section></summary><div class="docblock"><p>Initialize a persistent scan (inclusive prefix reduction) operation.</p>
<p>The returned handle can be started multiple times with <code>start()</code>.
Requires MPI 4.0+.</p>
<h5 id="arguments-28"><a class="doc-anchor" href="#arguments-28">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Send buffer</li>
<li><code>recv</code> - Receive buffer</li>
<li><code>op</code> - Reduction operation</li>
</ul>
<h5 id="example-51"><a class="doc-anchor" href="#example-51">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>send = <span class="macro">vec!</span>[<span class="number">1.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>persistent = world.scan_init(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, ReduceOp::Sum).unwrap();
<span class="kw">for _ in </span><span class="number">0</span>..<span class="number">100 </span>{
    persistent.start().unwrap();
    persistent.wait().unwrap();
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.exscan_init" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#2436-2463">Source</a><h4 class="code-header">pub fn <a href="#method.exscan_init" class="fn">exscan_init</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    op: <a class="enum" href="enum.ReduceOp.html" title="enum ferrompi::ReduceOp">ReduceOp</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.PersistentRequest.html" title="struct ferrompi::PersistentRequest">PersistentRequest</a>&gt;</h4></section></summary><div class="docblock"><p>Initialize a persistent exclusive scan (exclusive prefix reduction) operation.</p>
<p>The returned handle can be started multiple times with <code>start()</code>.
Requires MPI 4.0+.</p>
<h5 id="arguments-29"><a class="doc-anchor" href="#arguments-29">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Send buffer</li>
<li><code>recv</code> - Receive buffer (undefined on rank 0 after operation)</li>
<li><code>op</code> - Reduction operation</li>
</ul>
<h5 id="example-52"><a class="doc-anchor" href="#example-52">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>send = <span class="macro">vec!</span>[<span class="number">1.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>persistent = world.exscan_init(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, ReduceOp::Sum).unwrap();
<span class="kw">for _ in </span><span class="number">0</span>..<span class="number">100 </span>{
    persistent.start().unwrap();
    persistent.wait().unwrap();
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.alltoall_init" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#2490-2521">Source</a><h4 class="code-header">pub fn <a href="#method.alltoall_init" class="fn">alltoall_init</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.PersistentRequest.html" title="struct ferrompi::PersistentRequest">PersistentRequest</a>&gt;</h4></section></summary><div class="docblock"><p>Initialize a persistent all-to-all operation.</p>
<p>The returned handle can be started multiple times with <code>start()</code>.
Requires MPI 4.0+.</p>
<h5 id="arguments-30"><a class="doc-anchor" href="#arguments-30">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Send buffer (must contain <code>sendcount * size</code> elements)</li>
<li><code>recv</code> - Receive buffer (must contain <code>recvcount * size</code> elements)</li>
</ul>
<h5 id="example-53"><a class="doc-anchor" href="#example-53">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>size = world.size() <span class="kw">as </span>usize;
<span class="kw">let </span>send = <span class="macro">vec!</span>[<span class="number">1.0f64</span>; <span class="number">10 </span>* size];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">10 </span>* size];
<span class="kw">let </span><span class="kw-2">mut </span>persistent = world.alltoall_init(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv).unwrap();
<span class="kw">for _ in </span><span class="number">0</span>..<span class="number">100 </span>{
    persistent.start().unwrap();
    persistent.wait().unwrap();
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.gatherv_init" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#2552-2583">Source</a><h4 class="code-header">pub fn <a href="#method.gatherv_init" class="fn">gatherv_init</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recvcounts: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
    displs: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
    root: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.PersistentRequest.html" title="struct ferrompi::PersistentRequest">PersistentRequest</a>&gt;</h4></section></summary><div class="docblock"><p>Initialize a persistent gatherv operation (variable-count gather).</p>
<p>The returned handle can be started multiple times with <code>start()</code>.
Requires MPI 4.0+.</p>
<h5 id="arguments-31"><a class="doc-anchor" href="#arguments-31">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Send buffer</li>
<li><code>recv</code> - Receive buffer (significant only at root)</li>
<li><code>recvcounts</code> - Number of elements to receive from each rank</li>
<li><code>displs</code> - Displacement for each rank in the receive buffer</li>
<li><code>root</code> - Rank of the root process</li>
</ul>
<h5 id="example-54"><a class="doc-anchor" href="#example-54">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>send = <span class="macro">vec!</span>[<span class="number">1.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">40</span>];
<span class="kw">let </span>recvcounts = <span class="macro">vec!</span>[<span class="number">10i32</span>; <span class="number">4</span>];
<span class="kw">let </span>displs = <span class="macro">vec!</span>[<span class="number">0i32</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];
<span class="kw">let </span><span class="kw-2">mut </span>persistent = world.gatherv_init(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, <span class="kw-2">&amp;</span>recvcounts, <span class="kw-2">&amp;</span>displs, <span class="number">0</span>).unwrap();
<span class="kw">for _ in </span><span class="number">0</span>..<span class="number">100 </span>{
    persistent.start().unwrap();
    persistent.wait().unwrap();
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.scatterv_init" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#2614-2645">Source</a><h4 class="code-header">pub fn <a href="#method.scatterv_init" class="fn">scatterv_init</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    sendcounts: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
    displs: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    root: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.PersistentRequest.html" title="struct ferrompi::PersistentRequest">PersistentRequest</a>&gt;</h4></section></summary><div class="docblock"><p>Initialize a persistent scatterv operation (variable-count scatter).</p>
<p>The returned handle can be started multiple times with <code>start()</code>.
Requires MPI 4.0+.</p>
<h5 id="arguments-32"><a class="doc-anchor" href="#arguments-32">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Send buffer (significant only at root)</li>
<li><code>sendcounts</code> - Number of elements to send to each rank</li>
<li><code>displs</code> - Displacement for each rank in the send buffer</li>
<li><code>recv</code> - Receive buffer</li>
<li><code>root</code> - Rank of the root process</li>
</ul>
<h5 id="example-55"><a class="doc-anchor" href="#example-55">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>send = <span class="macro">vec!</span>[<span class="number">1.0f64</span>; <span class="number">40</span>];
<span class="kw">let </span>sendcounts = <span class="macro">vec!</span>[<span class="number">10i32</span>; <span class="number">4</span>];
<span class="kw">let </span>displs = <span class="macro">vec!</span>[<span class="number">0i32</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>persistent = world.scatterv_init(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;</span>sendcounts, <span class="kw-2">&amp;</span>displs, <span class="kw-2">&amp;mut </span>recv, <span class="number">0</span>).unwrap();
<span class="kw">for _ in </span><span class="number">0</span>..<span class="number">100 </span>{
    persistent.start().unwrap();
    persistent.wait().unwrap();
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.allgatherv_init" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#2675-2704">Source</a><h4 class="code-header">pub fn <a href="#method.allgatherv_init" class="fn">allgatherv_init</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recvcounts: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
    displs: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.PersistentRequest.html" title="struct ferrompi::PersistentRequest">PersistentRequest</a>&gt;</h4></section></summary><div class="docblock"><p>Initialize a persistent all-gatherv operation (variable-count all-gather).</p>
<p>The returned handle can be started multiple times with <code>start()</code>.
Requires MPI 4.0+.</p>
<h5 id="arguments-33"><a class="doc-anchor" href="#arguments-33">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Send buffer</li>
<li><code>recv</code> - Receive buffer</li>
<li><code>recvcounts</code> - Number of elements to receive from each rank</li>
<li><code>displs</code> - Displacement for each rank in the receive buffer</li>
</ul>
<h5 id="example-56"><a class="doc-anchor" href="#example-56">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>send = <span class="macro">vec!</span>[<span class="number">1.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">40</span>];
<span class="kw">let </span>recvcounts = <span class="macro">vec!</span>[<span class="number">10i32</span>; <span class="number">4</span>];
<span class="kw">let </span>displs = <span class="macro">vec!</span>[<span class="number">0i32</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];
<span class="kw">let </span><span class="kw-2">mut </span>persistent = world.allgatherv_init(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, <span class="kw-2">&amp;</span>recvcounts, <span class="kw-2">&amp;</span>displs).unwrap();
<span class="kw">for _ in </span><span class="number">0</span>..<span class="number">100 </span>{
    persistent.start().unwrap();
    persistent.wait().unwrap();
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.alltoallv_init" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#2741-2773">Source</a><h4 class="code-header">pub fn <a href="#method.alltoallv_init" class="fn">alltoallv_init</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    sendcounts: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
    sdispls: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recvcounts: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
    rdispls: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>],
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.PersistentRequest.html" title="struct ferrompi::PersistentRequest">PersistentRequest</a>&gt;</h4></section></summary><div class="docblock"><p>Initialize a persistent all-to-allv operation (variable-count all-to-all).</p>
<p>The returned handle can be started multiple times with <code>start()</code>.
Requires MPI 4.0+.</p>
<h5 id="arguments-34"><a class="doc-anchor" href="#arguments-34">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Send buffer</li>
<li><code>sendcounts</code> - Number of elements to send to each rank</li>
<li><code>sdispls</code> - Send displacement for each rank</li>
<li><code>recv</code> - Receive buffer</li>
<li><code>recvcounts</code> - Number of elements to receive from each rank</li>
<li><code>rdispls</code> - Receive displacement for each rank</li>
</ul>
<h5 id="example-57"><a class="doc-anchor" href="#example-57">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>send = <span class="macro">vec!</span>[<span class="number">1.0f64</span>; <span class="number">40</span>];
<span class="kw">let </span>sendcounts = <span class="macro">vec!</span>[<span class="number">10i32</span>; <span class="number">4</span>];
<span class="kw">let </span>sdispls = <span class="macro">vec!</span>[<span class="number">0i32</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">40</span>];
<span class="kw">let </span>recvcounts = <span class="macro">vec!</span>[<span class="number">10i32</span>; <span class="number">4</span>];
<span class="kw">let </span>rdispls = <span class="macro">vec!</span>[<span class="number">0i32</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];
<span class="kw">let </span><span class="kw-2">mut </span>persistent = world.alltoallv_init(
    <span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;</span>sendcounts, <span class="kw-2">&amp;</span>sdispls,
    <span class="kw-2">&amp;mut </span>recv, <span class="kw-2">&amp;</span>recvcounts, <span class="kw-2">&amp;</span>rdispls,
).unwrap();
<span class="kw">for _ in </span><span class="number">0</span>..<span class="number">100 </span>{
    persistent.start().unwrap();
    persistent.wait().unwrap();
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reduce_scatter_block_init" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#2801-2829">Source</a><h4 class="code-header">pub fn <a href="#method.reduce_scatter_block_init" class="fn">reduce_scatter_block_init</a>&lt;T: <a class="trait" href="trait.MpiDatatype.html" title="trait ferrompi::MpiDatatype">MpiDatatype</a>&gt;(
    &amp;self,
    send: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    recv: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.slice.html">[T]</a>,
    op: <a class="enum" href="enum.ReduceOp.html" title="enum ferrompi::ReduceOp">ReduceOp</a>,
) -&gt; <a class="type" href="type.Result.html" title="type ferrompi::Result">Result</a>&lt;<a class="struct" href="struct.PersistentRequest.html" title="struct ferrompi::PersistentRequest">PersistentRequest</a>&gt;</h4></section></summary><div class="docblock"><p>Initialize a persistent reduce-scatter-block operation.</p>
<p>The returned handle can be started multiple times with <code>start()</code>.
Requires MPI 4.0+.</p>
<h5 id="arguments-35"><a class="doc-anchor" href="#arguments-35">§</a>Arguments</h5>
<ul>
<li><code>send</code> - Send buffer (must contain <code>recvcount * size</code> elements)</li>
<li><code>recv</code> - Receive buffer</li>
<li><code>op</code> - Reduction operation</li>
</ul>
<h5 id="example-58"><a class="doc-anchor" href="#example-58">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>size = world.size() <span class="kw">as </span>usize;
<span class="kw">let </span>send = <span class="macro">vec!</span>[<span class="number">1.0f64</span>; <span class="number">10 </span>* size];
<span class="kw">let </span><span class="kw-2">mut </span>recv = <span class="macro">vec!</span>[<span class="number">0.0f64</span>; <span class="number">10</span>];
<span class="kw">let </span><span class="kw-2">mut </span>persistent = world.reduce_scatter_block_init(<span class="kw-2">&amp;</span>send, <span class="kw-2">&amp;mut </span>recv, ReduceOp::Sum).unwrap();
<span class="kw">for _ in </span><span class="number">0</span>..<span class="number">100 </span>{
    persistent.start().unwrap();
    persistent.wait().unwrap();
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.abort" class="method"><a class="src rightside" href="../src/ferrompi/comm.rs.html#2856-2859">Source</a><h4 class="code-header">pub fn <a href="#method.abort" class="fn">abort</a>(&amp;self, errorcode: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.i32.html">i32</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.never.html">!</a></h4></section></summary><div class="docblock"><p>Abort MPI execution across all processes in this communicator.</p>
<p>This function terminates all processes associated with the communicator.
It calls <code>MPI_Abort</code> and then exits the process. This function never
returns.</p>
<h5 id="arguments-36"><a class="doc-anchor" href="#arguments-36">§</a>Arguments</h5>
<ul>
<li><code>errorcode</code> - Error code to return to the invoking environment</li>
</ul>
<h5 id="example-59"><a class="doc-anchor" href="#example-59">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">if </span>world.rank() == <span class="number">0 </span>{
    <span class="comment">// Fatal error detected, abort all processes
    </span>world.abort(<span class="number">1</span>);
}</code></pre></div></div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Communicator" class="impl"><a class="src rightside" href="../src/ferrompi/comm.rs.html#59">Source</a><a href="#impl-Clone-for-Communicator" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.93.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Communicator.html" title="struct ferrompi::Communicator">Communicator</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../src/ferrompi/comm.rs.html#59">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.1/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Communicator.html" title="struct ferrompi::Communicator">Communicator</a></h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="https://doc.rust-lang.org/1.93.1/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.93.1/src/core/clone.rs.html#245-247">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.1/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.93.1/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Drop-for-Communicator" class="impl"><a class="src rightside" href="../src/ferrompi/comm.rs.html#2862-2869">Source</a><a href="#impl-Drop-for-Communicator" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.93.1/core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop">Drop</a> for <a class="struct" href="struct.Communicator.html" title="struct ferrompi::Communicator">Communicator</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.drop" class="method trait-impl"><a class="src rightside" href="../src/ferrompi/comm.rs.html#2863-2868">Source</a><a href="#method.drop" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.1/core/ops/drop/trait.Drop.html#tymethod.drop" class="fn">drop</a>(&amp;mut self)</h4></section></summary><div class='docblock'>Executes the destructor for this type. <a href="https://doc.rust-lang.org/1.93.1/core/ops/drop/trait.Drop.html#tymethod.drop">Read more</a></div></details></div></details><section id="impl-Send-for-Communicator" class="impl"><a class="src rightside" href="../src/ferrompi/comm.rs.html#71">Source</a><a href="#impl-Send-for-Communicator" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.93.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Communicator.html" title="struct ferrompi::Communicator">Communicator</a></h3></section><section id="impl-Sync-for-Communicator" class="impl"><a class="src rightside" href="../src/ferrompi/comm.rs.html#72">Source</a><a href="#impl-Sync-for-Communicator" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.93.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Communicator.html" title="struct ferrompi::Communicator">Communicator</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Communicator" class="impl"><a href="#impl-Freeze-for-Communicator" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.93.1/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.Communicator.html" title="struct ferrompi::Communicator">Communicator</a></h3></section><section id="impl-RefUnwindSafe-for-Communicator" class="impl"><a href="#impl-RefUnwindSafe-for-Communicator" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.93.1/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Communicator.html" title="struct ferrompi::Communicator">Communicator</a></h3></section><section id="impl-Unpin-for-Communicator" class="impl"><a href="#impl-Unpin-for-Communicator" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.93.1/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Communicator.html" title="struct ferrompi::Communicator">Communicator</a></h3></section><section id="impl-UnwindSafe-for-Communicator" class="impl"><a href="#impl-UnwindSafe-for-Communicator" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.93.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Communicator.html" title="struct ferrompi::Communicator">Communicator</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.1/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.93.1/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.93.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.1/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.1/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.93.1/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.93.1/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.1/src/core/borrow.rs.html#212">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.93.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.93.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.1/src/core/borrow.rs.html#214">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.1/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.93.1/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.1/src/core/borrow.rs.html#221">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.93.1/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.93.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.1/src/core/borrow.rs.html#222">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.93.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.1/src/core/clone.rs.html#547">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.93.1/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.93.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.1/src/core/clone.rs.html#549">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/1.93.1/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/1.93.1/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.1/src/core/convert/mod.rs.html#785">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.93.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.1/src/core/convert/mod.rs.html#788">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.1/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.1/src/core/convert/mod.rs.html#767-769">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.93.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.93.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.1/src/core/convert/mod.rs.html#777">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.1/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.93.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.1/src/alloc/borrow.rs.html#85-87">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.93.1/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.93.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.1/src/alloc/borrow.rs.html#89">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.93.1/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.1/src/alloc/borrow.rs.html#90">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.1/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.93.1/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.1/src/alloc/borrow.rs.html#94">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.1/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.93.1/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.93.1/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.1/src/core/convert/mod.rs.html#827-829">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.93.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.93.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.1/src/core/convert/mod.rs.html#831">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.93.1/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.93.1/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.1/src/core/convert/mod.rs.html#834">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.1/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.93.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.93.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.93.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.1/src/core/convert/mod.rs.html#811-813">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.93.1/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.93.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.1/src/core/convert/mod.rs.html#815">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.93.1/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.93.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.93.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.93.1/src/core/convert/mod.rs.html#818">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.93.1/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.93.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.93.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.93.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>